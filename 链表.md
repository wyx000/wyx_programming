### 链表

#### 基本信息

``` c++

  Definition for singly-linked list.
  struct ListNode {
      int val;
      ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
      ListNode(int x, ListNode *next) : val(x), next(next) {}
  };
 
```



- 常见的包括单链表/双向链表/循环链表
- 基本都在考察对链表的**增删改查操作**
- 需要注意的点
  - **双指针法**，比如快慢指针、同向、反向指针等
  - **Dummy node**. Dummy Node 其实就是带头节点的指针
  - **临界问题**.  考虑链表是否为空， 结尾节点next指针是否有设置为nullptr; 在遍历中往往需要考虑指针是否为空。



#### 查找节点

##### 141. 环形链表

> 给定一个链表，判断链表中是否有环。

1. **记录链表指针，使用哈希表存储，检查是否出现重复**； 时间复杂度O(n)； 空间复杂度 O(n)

``` c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> seens; // 存储链表节点指针
        while(head){
            if(seens.count(head)){
                return true;
            }
            seens.insert(head);
            head=head->next;
        }
        return false;
    }
};
```



2. 快慢指针 

- 判断快指针是否出现从后追上慢指针的情况，即出现环链； 时间复杂度为O(n)，空间复杂度为O(1)

``` c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==NULL) return false;
        
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast->next){
            
            if(fast->next->next){//fast->next->next不为空
                fast=fast->next->next;
                slow=slow->next;
                if(fast==slow) 
                    return true;
            }
            else{
                return false;
            }
        } 
        return false;
    }
};
```



#### 142. 环形链表2 找入口节点 [Medium]

> 找到环形链表的入口节点

- 判断有环的进阶版题目
  - **在找到有环后，移动slow指针，从头重新移动，调整快慢指针速度，都设为1**
  - 当两者再次相遇时即为环的入口
  - fast - slow = k 即环长度的整数倍
  - 当前fast到入口的距离为m, 那么head到入口为k-m,
    - fast向前移动k-m到达入口(m + k -m)
    - head从头移动k-m也到达入口

``` c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;

        if(!head) return nullptr;

        bool flag = false;
        while(fast && fast->next){     //存在环，找相遇点
            fast = fast -> next->next;
            slow = slow ->next;
            if(fast==slow){
                flag = true;
                break;
            }      
        }

        if(!flag) return nullptr;//没有环
        slow = head;
        while(slow != fast){
            fast= fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



#### 删除节点

#### 链表翻转操作

##### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> 输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

- 一次遍历，双指针 `prev` `cur`
  - 记录前一个节点，修改当前节点的指针为前一个节点，完成翻转
  - 返回最后一个节点的指针
  - 时间复杂度O(N),空间复杂度O(1)

- 关键点：` 一次遍历+双指针 `  `递归解法`

1. 一次遍历+双指针 

``` c++
ListNode* reverseList(ListNode* head) {
    
    if(head==NULL||head->next==NULL) return head;//仅有一个元素或空
    
    ListNode* cur = head;
    ListNode* prev = NULL;

    while(cur){
        ListNode*next = cur ->next;
        cur->next =prev;
        prev = cur;
        cur = next;
    }

    return prev;
}
```



2. **递归反转链表**

   ![img](https://raw.githubusercontent.com/wyx000/wyx_programming/master/pics/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png)

``` c++
ListNode* reverseList(ListNode* head) {    
	if(head==NULL||head->next==NULL) return head;

    ListNode *p = reverseList(head->next);//递归head->next
    head->next->next=head;
    head->next=NULL;
    return p;//返回p
}
```



#### 局部反转： 反转链表前N个元素

![image-20210426151224281.png](https://github.com/wyx000/wyx_programming/blob/master/pics/image-20210426151224281.png?raw=true)

- `reverseN(head, 3)` 给定头指针，反转前3个元素，返回头指针

  ；

  - 仍然将问题简化为两步： 给定head，对于head->next后的N-1个元素，通过reverseN(head->next,N-1);
  - 完成反转后，将head和head->next进行反转，并**将head的next指向原来链表中的第N+1个元素**
  - 这个N+1元素需要在递归中提前记录，并将其作为递归终止的条件。

``` c++
    ListNode* successor  = NULL;

    ListNode* reverseHead(ListNode* head, int n){//反转从head开始之后n个链表
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* p =reverseHead(head->next, n-1);
        head->next->next=head;
        head->next=successor;
        return p;
    }
```



#### 局部反转：反转链表中第[m,n]个元素

可以把问题进行简化，当**指针遍历到需要开始翻转的位置时**调用前面的reverseN即可：

- head->next=reverse(head->next,m-1,n-1): 直观看就是在链表遍历，m-1和n-1即保证反转的相对位置不变；
- 对于reverse中m==1 表明已经到达待翻转位置：

``` c++
class Solution {
public:
    ListNode* successor  = NULL;
    ListNode* reverseHead(ListNode* head, int n){//反转从head开始之后n个链表
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* p =reverseHead(head->next, n-1);
        head->next->next=head;
        head->next=successor;
        return p;
    }


    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left==1){
            return reverseHead(head,right);
        }
        head->next = reverseBetween(head->next,left - 1, right -1);// right-1保证反转的相对位置不变
        return head;
    }
};
```



#### 链表合并

#### 混合操作

