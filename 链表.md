### 链表

#### 基本信息

``` c++

  Definition for singly-linked list.
  struct ListNode {
      int val;
      ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
      ListNode(int x, ListNode *next) : val(x), next(next) {}
  };
 
```



- 常见的包括单链表/双向链表/循环链表
- 基本都在考察对链表的**增删改查操作**
- 需要注意的点
  - **双指针法**，比如快慢指针、同向、反向指针等
  - **Dummy node**. Dummy Node 其实就是带头节点的指针
  - **临界问题**.  考虑链表是否为空， 结尾节点next指针是否有设置为nullptr; 在遍历中往往需要考虑指针是否为空。



#### 查找节点

##### 环形链表

> 

#### 删除节点

#### 链表翻转操作

##### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> 输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

- 一次遍历，双指针 `prev` `cur`
  - 记录前一个节点，修改当前节点的指针为前一个节点，完成翻转
  - 返回最后一个节点的指针
  - 时间复杂度O(N),空间复杂度O(1)

- 关键点：` 一次遍历+双指针 `  `递归解法`

1. 一次遍历+双指针 

``` c++
ListNode* reverseList(ListNode* head) {
    
    if(head==NULL||head->next==NULL) return head;//仅有一个元素或空
    
    ListNode* cur = head;
    ListNode* prev = NULL;

    while(cur){
        ListNode*next = cur ->next;
        cur->next =prev;
        prev = cur;
        cur = next;
    }

    return prev;
}
```



2. **递归反转链表**

   ![image-20210426124055276](C:\Users\ninan\Desktop\面试\leetcode\wyx_programming\pics\反转链表.png)

``` c++
ListNode* reverseList(ListNode* head) {    
	if(head==NULL||head->next==NULL) return head;

    ListNode *p = reverseList(head->next);//递归head->next
    head->next->next=head;
    head->next=NULL;
    return p;//返回p
}
```



#### 局部反转： 反转链表前N个元素

- reverseN(head, 3) 给定头指针，反转前3个元素，返回头指针

  ；

  - 仍然将问题简化为两步： 给定head，对于head->next后的N-1个元素，通过reverseN(head->next,N-1);
  - 完成反转后，将head和head->next进行反转，并将head的next指向原来链表中的第N+1个元素
  - 这个N+1元素需要在递归中提前记录，并将其作为递归终止的条件。



#### 链表合并

#### 混合操作

