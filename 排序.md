
- [排序算法](#排序算法)
  - [比较排序 vs 非比较排序](#比较排序-vs-非比较排序)
  - [0.冒泡排序](#0冒泡排序)
  - [1.快速排序](#1快速排序)
  - [题目](#题目)
  - [数组第k大的元素 [基于快速选择排序，基于堆排序]](#数组第k大的元素-基于快速选择排序基于堆排序)


### 排序算法

![img](https://github.com/wyx000/Coding_Exercise_2021/raw/0424fff/leetcode/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2/summary.png)

动画图解：https://github.com/chefyuan/algorithm-base https://zhuanlan.zhihu.com/p/60152722

------

#### 比较排序 vs 非比较排序

**比较排序：**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。<u>每个数都必须和其他数进行比较，才能确定自己的位置</u>。

- 快速排序、归并排序、堆排序、冒泡排序

  冒泡排序，问题规模为n，又因为需要比较n次，平均时间复杂度为O(n²)。

  在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。

- **比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。**

**非比较排序：**非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。

- 计数排序、基数排序、桶排序
-  **非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**

------



#### 0.冒泡排序

- 特点：遍历进行对比交换，时间复杂度 O(N2), 稳定排序

```c++
	void BubbleSort(vector<int>& arr){
    int L = arr.size()-1;
    for (int i = 0 ; i < L; i++){
        bool flag = false;
        for(int j = 0; j < L - 1 - i; j++){ //每一趟把最大的数放在排序的末尾
            if(arr[j]>arr[j+1]){
                swap(arr[j], arr[j+1]);
                flag = true;    //若某次未交换则无需再比较，退出
            }
        }

        if (! flag) break;

    }
}
```



#### 1.快速排序

- 左右交换，递归进行
  - 选择基准元素，一趟排序后一部分大于基准元素，一部分小于基准元素
  - 此时基准元素在排好序后的位置

- 复杂度
  - 空间：O(LogN)
  - 时间：O(NLogN), 最差 O(N^2)
    - **时间复杂度与划分点选择相关，如果选中的划分点可以平分序列，那么总划分次数就会是logn**
    - **如果每次选中的划分点为最小/最大值，那么总有一个空区间，剩下的部分等价于线性处理，时间复杂度为O(n^2)**
    - 优化方法为：通常采用“三者值取中”方法，即比较r[low].key、r[high].key与r[(low+high)/2].key，**取三者中关键字为中值的元素为中间数** （解决序列部分有序的问题）
- 快排优化：参考：https://blog.csdn.net/qq_19525389/article/details/81436838
  - 3种取基准的方法
    - 随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）
  - 4种优化方式
    - 优化1：当待排序序列的长度分割到一定大小后，使用插入排序 **处理序列中有重复的情况** 当待排序列长度为5~20之间，此时使用插入排序能避免效率下降
    - 优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割 **有效提高对有重复数据的序列处理速度** 将与当前pivot基准相同的元素在交换的时候都移到数组头部； 在完成交换后，再从头部交换到基准附近，从而将所有相等的值都聚合起来，大幅降低处理速度
    - 优化3：优化递归操作
    - 优化4：**使用并行或多线程处理子序列**

```c++
//1. 快速排序
int Partition( vector<int> &arr, int left, int right){
    int pivot = arr[left]; //基准最后放在左边
    int start = left;

    while(left<right){

        while(left<right && arr[right] >= pivot){ //先从右边开始比较
              right--;}


        while(left<right && arr[left] <= pivot){
            left++;
        }

        if (left < right){
            swap(arr[left],arr[right]);//交换左右的元素，使得左小右大
        }
    }

    swap(arr[start],arr[left]);//记录的最开始的左侧和现在的左侧交换

    return left;//返回当前的划分位置


}

void quickSort(vector<int>& arr, int left, int right){

    if (left>=right)//左右相遇时停止
        return;
    int p = Partition(arr,left,right);//返回划分的index

    cout<< p << endl;
    quickSort(arr,left,p-1);//排列左边
    quickSort(arr,p+1,right);//排列右边
}
```





- 优化，随机选取主元（时间O（logN））

```c++
int partition(vector<int>& nums, int left, int right) {...}//partition同上
//随机划分函数
int randomized_partition(vector<int>& nums, int left, int right){
    int i =rand()%(right-left+1)+left;//随机选取一个作为主元
    swap(nums[left],nums[i]);//交换随机元到左侧头部
    return partition(nums,left,right);
}

    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int p = randomized_partition(nums, left, right);
        quickSort(nums, left, p - 1);
        quickSort(nums, p + 1, right);
    }
```

- 代码精简版

  ```c++
  void quick_sort(vector<int>& arr, int l, int r){
  	if(l < r){
  		int i = l, j =r;
  		
  		while(i<j){
              while(i<j && arr[j]>=arr[l])j--;
              while(i<j && arr[i] <= arr[l])i++;
              swap(nums[i],nums[j]);
          }
          
          swap(nums[l],nums[i]);
          quick_sort(arr,l,i-1);
          quick_sort(arr,i+1,r);
  	}
  
  }
  ```

  



#### 题目

#### 数组第k大的元素 [基于快速选择排序，基于堆排序]

![image-20210424222957902](C:\Users\ninan\AppData\Roaming\Typora\typora-user-images\image-20210424222957902.png)
1. 快速选择排序

```c++
class Solution {
public:

//1.快速选择 快排+随机选择
    int quickSelect(vector<int>& a, int l, int r, int index){
        int q = randomPartition(a,l,r);//位置q的一个随机划分
        if(q==index){
            return a[q];
        }
        else
            return q<index? quickSelect(a,q+1,r,index):quickSelect(a,l,q-1,index);
            //位置q比index小？左侧随机划分
            //位置q比index大？右侧随机划分
    }

    int randomPartition(vector<int>&a,int l,int r){
        int i= rand()%(r-l+1)+l;//l-r之间的一个任意数
        swap(a[i],a[r]);//将要比较的放在末尾
        return partition (a,l,r);//划分区间（l,r）
    }

    int partition (vector<int>&arr,int l, int r){
        int start=l;
        while(l<r){
            while(l<r && arr[r]>=arr[start]) r--;
            while(l<r && arr[l]<=arr[start]) l++;
            swap(arr[l],arr[r]);
        }
        swap(arr[start],arr[l]);
        return l;     
    }

    int findKthLargest(vector<int>& nums, int k) {
        //返回位置在k的数字
        return quickSelect(nums,0,nums.size()-1,nums.size()-k);

    }
};
```

2. 堆排序