- [计算机网络体系结构](#计算机网络体系结构)
  - [体系结构](#体系结构)
  - [网络层协议](#网络层协议)
    - [路由器、交换机位于哪一层？](#路由器交换机位于哪一层)
    - [什么叫划分子网？](#什么叫划分子网)
    - [什么是ARP协议 (Address Resolution Protocol)？](#什么是arp协议-address-resolution-protocol)
  - [什么是NAT (Network Address Translation, 网络地址转换)？](#什么是nat-network-address-translation-网络地址转换)
- [传输层：TCP和UDP](#传输层tcp和udp)
  - [TCP介绍](#tcp介绍)
    - [TCP如何保证传输的可靠性](#tcp如何保证传输的可靠性)
    - [TCP粘包](#tcp粘包)
  - [UDP介绍](#udp介绍)
    - [UDP如何实现可靠传输](#udp如何实现可靠传输)
  - [TCP和UDP的区别](#tcp和udp的区别)
    - [什么时候选择TCP，什么时候选UDP？](#什么时候选择tcp什么时候选udp)
    - [HTTP可以使用UDP吗？](#http可以使用udp吗)
    - [面向连接和无连接的区别](#面向连接和无连接的区别)
  - [TCP和UDP相关的协议与端口号](#tcp和udp相关的协议与端口号)
  - [TCP（UDP，IP）等首部的认识（http请求报文构成）](#tcpudpip等首部的认识http请求报文构成)
  - [TCP/IP的粘包与避免介绍一下](#tcpip的粘包与避免介绍一下)
  - [说一下TCP的封包和拆包](#说一下tcp的封包和拆包)
- [三次握手四次挥手](#三次握手四次挥手)
  - [三次握手](#三次握手)
    - [为什么使用三次握手，两次握手可不可以？](#为什么使用三次握手两次握手可不可以)
    - [可以采用四次握手吗？为什么？](#可以采用四次握手吗为什么)
    - [第三次握手中，如果客户端的ACK未送达服务器，会怎样？](#第三次握手中如果客户端的ack未送达服务器会怎样)
    - [如果已经建立了连接，但客户端出现了故障怎么办？](#如果已经建立了连接但客户端出现了故障怎么办)
    - [初始序列号是什么？](#初始序列号是什么)
    - [TCP三次握手时的第一次的seq序号是怎样产生的](#tcp三次握手时的第一次的seq序号是怎样产生的)
  - [四次挥手](#四次挥手)
    - [为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？](#为什么不能把服务器发送的ack和fin合并起来变成三次挥手close_wait状态意义是什么)
    - [如果第二次挥手时服务器的ACK没有送达客户端，会怎样？](#如果第二次挥手时服务器的ack没有送达客户端会怎样)
    - [客户端TIME_WAIT状态的意义是什么？](#客户端time_wait状态的意义是什么)
    - [四次挥手**TIME_WAIT的意义（为什么要等于2MSL）**](#四次挥手time_wait的意义为什么要等于2msl)
    - [服务器出现大量close_wait的连接的原因以及解决方法](#服务器出现大量close_wait的连接的原因以及解决方法)
- [流量控制和拥塞控制](#流量控制和拥塞控制)
  - [拥塞控制和流量控制的区别](#拥塞控制和流量控制的区别)
  - [流量控制介绍](#流量控制介绍)
  - [tcp滑动窗口协议](#tcp滑动窗口协议)
    - [采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？](#采用滑动窗口会有什么问题死锁可能糊涂窗口综合征)
  - [拥塞控制的实现](#拥塞控制的实现)
  - [TCP速率受到三个因素影响](#tcp速率受到三个因素影响)
- [应用层：HTTP和HTTPS](#应用层http和https)
  - [HTTP和HTTPS有什么区别？](#http和https有什么区别)
    - [Https的连接过程？](#https的连接过程)
    - [对称加密和非对称加密](#对称加密和非对称加密)
    - [数字签名、报文摘要的原理](#数字签名报文摘要的原理)
  - [GET与POST的区别？](#get与post的区别)
  - [Session与Cookie的区别？](#session与cookie的区别)
  - [从输入网址到获得页面的过程 (越详细越好)](#从输入网址到获得页面的过程-越详细越好)
    - [DNS解析有两种方式：**递归查询**和**迭代查询**](#dns解析有两种方式递归查询和迭代查询)
  - [HTTP请求有哪些常见状态码？](#http请求有哪些常见状态码)
- [其他](#其他)
  - [单条记录高并发访问的优化](#单条记录高并发访问的优化)
  - [介绍一下ping的过程，分别用到了哪些协议](#介绍一下ping的过程分别用到了哪些协议)
## 计算机网络体系结构

### 体系结构

![计算机网络体系结构](.\pics\20191129195451183_16713.png)

- Physical, Data Link, Network, Transport, Application
- 应用层：常见协议：
  - FTP(21端口)：文件传输协议
  - SSH(22端口)：远程登陆
  - TELNET(23端口)：远程登录
  - SMTP(25端口)：发送邮件
  - POP3(110端口)：接收邮件
  - HTTP(80端口)：超文本传输协议
  - DNS(53端口)：运行在UDP上，域名解析服务
- 传输层：TCP/UDP
- 网络层：IP、ARP、NAT、RIP...

### 网络层协议

#### 路由器、交换机位于哪一层？
路由器网络层，根据IP地址进行寻址；
交换机数据链路层，根据MAC地址进行寻址

#### 什么叫划分子网？

从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

#### 什么是ARP协议 (Address Resolution Protocol)？

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP  地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。



### 什么是NAT (Network Address Translation, 网络地址转换)？

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

## 传输层：TCP和UDP

### TCP介绍

- TCP（Transmission     Control Protocol，传输控制协议）是一种**面向连接的、可靠的、基于字节流的传输层通信协议**，其传输的单位是**报文段**。

**特征：**

- 面向连接
- 只能点对点（一对一）通信
- 可靠交互
- 全双工通信
- 面向字节流

**TCP 如何保证可靠传输：**

- 确认和超时重传
- 数据合理分片和排序
- 流量控制
- 拥塞控制
- 数据校验

#### TCP如何保证传输的可靠性

* **校验和**
  发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 
* **确认应答+序列号**
  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
* **超时重传**
  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
* **流量控制**
  TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。
  - 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是<u>可变大小的滑动窗口协议</u>。
    接收方有即时窗口（滑动窗口），随ACK报文发送
* **拥塞控制**
  当网络拥塞时，减少数据的发送。
  发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小

慢启动、拥塞避免、快速重传、快速恢复 

#### TCP粘包

**原因**

TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。

**解决**

- <u>发送定长包</u>。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- <u>包头说明包体长度</u>。包头是定长的 4     个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
- <u>在数据包之间设置边界</u>，如添加特殊符号     \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。
- 使用更加复杂的应用层协议。

### UDP介绍

- UDP（User Datagram     Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联）     参考模型中一种**无连接的传输层协议**，提供面向事务的**简单不可靠信息传送服务**，其传输的单位是**用户数据报**。

特征：

- 无连接
- 尽最大努力交付
- 面向报文
- 没有拥塞控制
- 支持一对一、一对多、多对一、多对多的交互通信
- 首部开销小

####  UDP如何实现可靠传输

因为UDP是无连接的协议，所以在<u>传输层上无法保证可靠传输</u>，要想实现可靠传输，只能<u>从应用层实现</u>。需要实现<u>**seq/ack机制，重传机制和窗口确认机制**</u>。

就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。

### TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的；
	无连接:UDP发送数据之前不需要建立连接
2. TCP是可靠的，UDP不可靠；
	不可靠：UDP接收方收到报文后，不需要给出任何确认
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；
	面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
5. TCP有拥塞控制和流量控制。UDP没有，网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；
	
	（6. TCP首部开销（20字节）比UDP首部开销（8字节）要大
	7. UDP 的主机不需要维持复杂的连接状态表）

#### 什么时候选择TCP，什么时候选UDP？
对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失


#### HTTP可以使用UDP吗？
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠

#### 面向连接和无连接的区别

- 无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）
	- 虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；
	- 数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；

**其他补充 TCP和UDP的差别**

* <u>TCP是面向连接的协议</u>，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。
* <u>TCP提供流量控制和拥塞控制</u>，而UDP没有。
* TCP对系统资源的要求高于UDP，所以速度也比UDP慢。
* <u>TCP数据包是没有边界的，会出现粘包的问题</u>，UDP包是独立的，不会出现粘包问题。
* 所以在应用方面，如果**强调数据的完整性和正确性用TCP**，当要求**性能和速度的时候，使用UDP**更加合适。

注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。

### TCP和UDP相关的协议与端口号

TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。
详见：https://blog.csdn.net/qq_22080999/article/details/81105051

### TCP（UDP，IP）等首部的认识（http请求报文构成）

**TCP的头部**大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等

**UDP的头部**则包括：源端口，目的端口，长度，校验和。

**IP数据包的头部**包括：源IP地址，目的IP地址，协议，校验和，总长度等等

详见：https://blog.csdn.net/zhangliangzi/article/details/52554439



###  TCP/IP的粘包与避免介绍一下

因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。**而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。**

导致TCP粘包的原因有三方面：

* 发送端等待缓冲区满才进行发送，造成粘包
* 接收方来不及接收缓冲区内的数据，造成粘包
* 由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送

避免粘包的措施：

* 通过编程，强制使TCP发生数据传送，不必等到缓冲区满
* 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等
* 设置固定长度的报文或者设置报文头部指示报文的长度。

### 说一下TCP的封包和拆包

因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。

* 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
* 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。



## 三次握手四次挥手

### 三次握手

![三次握手](.\pics\20191129101827556_21212.png)

- 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入**SYN_SENT**状态；
- 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入**SYN_RCVD**状态；
- 第三次握手：客户端检查acknowledge  number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge  number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge  number为序列号+1之后，也进入**ESTABLISHED**状态；完成三次握手，连接建立。

#### 为什么使用三次握手，两次握手可不可以？

两个原因

- 能会出现**已失效的连接请求报文段又传到了服务器端**。

  > client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达  server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client  再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。
  >
  > 假设不采用 “三次握手”，那么只要 server  发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server  发送数据。**但 server 却以为新的运输连接已经建立**，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用  “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。**server  由于收不到确认，就知道 client 并没有要求建立连接。**

- 两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。

#### 可以采用四次握手吗？为什么？
可以。但是会降低传输的效率。
- 握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；
- 原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。


#### 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

- Server端：
由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

- Client端，两种情况：
在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态
在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包(RESET)应答。

#### 如果已经建立了连接，但客户端出现了故障怎么办？

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 初始序列号是什么？
CP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN）
比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，**B可以确认什么样的数据编号是合法的**；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。

#### TCP三次握手时的第一次的seq序号是怎样产生的

第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。

seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。

### 四次挥手

![四次挥手](.\pics\20191129112652915_15481.png)

- 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入**FIN_WAIT_1**状态；
- 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入**CLOSE_WAIT**状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
- 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入**LAST_ACK**状态；
- 第四次挥手：Client收到服务器的FIN后，进入**TIME_WAIT**状态；接着将ACK置1，发送一个acknowledge  number=序列号+1给服务器；服务器收到后，确认acknowledge  number后，变为**CLOSED**状态，不再向客户端发送数据。**客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态**。完成四次挥手。

#### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。



#### 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？
客户端没有收到ACK确认，会重新发送FIN请求。

#### 客户端TIME_WAIT状态的意义是什么？

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。
MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### 四次挥手**TIME_WAIT的意义（为什么要等于2MSL）**

TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但网络是不可靠的，有可以最后一个ACK丢失。<u>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。</u>若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。

（<u>防止已失效的连接请求报文段出现在本连接中</u>。TIME-WAIT     持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。）

#### 服务器出现大量close_wait的连接的原因以及解决方法

close_wait状态是在<u>TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的</u>，服务器出现大量close_wait状态的原因有两种：

* 服务器<u>内部业务处理占用了过多时间</u>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法
* 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致<u>socket的引用不为0无法回收</u>

处理方法：

* 停止应用程序
* 修改程序里的bug

## 流量控制和拥塞控制

### 拥塞控制和流量控制的区别

**拥塞控制**是**防止过多的数据注入到网络**中，导致网络发生拥塞；而**流量控制**是**防止发送方一下子发送过多的数据到接收方**，导致接收方缓存放不下。两种算法都是<u>对发送方的行为进行控制</u>的。

### 流量控制介绍

所谓**流量控制**就是让发送方发送速率不要过快，让接收方来得及接收。

使用**滑动窗口协议**实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver  window（窗口大小单位是字节），<u>接受窗口的大小是根据自己的资源情况动态调整的</u>，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

![滑动窗口](.\pics\1615897397.gif)

发送窗口的<u>上限为接受窗口和拥塞窗口中的较小值</u>。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

### tcp滑动窗口协议

详见 [TCP-IP详解：滑动窗口SlidingWindow](https://blog.csdn.net/wdscq1234/article/details/52444277)和[TCP滑动窗口](https://www.cnblogs.com/alifpga/p/7675850.html)

TCP的滑动窗口用来<u>控制接收方和发送方的发送速率</u>，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。

接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。

#### 采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？

**死锁可能：**考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。

**解决**方法**：TCP为每一个连接设置一个**持续计时器**（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，<u>周期性的发送一个零窗口探测报文段</u>。以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。

### 拥塞控制的实现



![拥塞控制](.\pics\20191129153624025_28293.png)

拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**

1. **慢启动**：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍

[![slow start](.\pics\20191129155345024_11142.png)

2. **拥塞避免**：当拥塞窗口的大小<u>达到慢开始门限</u>(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.

> 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（**其根据就是没有收到确认**），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。**（这是不使用快重传的情况）**

3. **快重传**：快重传要求接收方在<u>收到一个失序的报文段后就立即发出**重复确认**</u>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当<u>立即重传对方尚未收到的报文段</u>，而不必继续等待设置的重传计时器时间到期。

[![快重传](.\pics\20191129161026032_32431.png)

4. **快恢复**：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。

   不执行慢开始算法的原因：因为<u>如果网络出现拥塞的话就不会收到好几个重复的确认</u>，所以发送方认为现在网络可能没有出现拥塞。
    也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS  。这样做的理由是：

   - 既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。

   - 这三个分组不再消耗网络的资源而是停留在接收方的缓存中。

   - 可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。

### TCP速率受到三个因素影响

- 窗口：即滑动窗口大小，见[TCP如何实现流量控制？](https://github.com/wolverinn/Waking-Up/blob/master/Computer Network.md#TCP如何实现流量控制)
- 带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。
- RTT：即Round Trip  Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission  TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则任务数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。

## 应用层：HTTP和HTTPS

### HTTP和HTTPS有什么区别？

1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买
5. http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。

#### Https的连接过程？

https包括非对称加密和对称加密两个阶段，在**客户端与服务器**建立连接的时候使用**非对称加密**，连接建立以后使用的是对称加密。

1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接
2. Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。
3. 客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
4. Web服务器利用自己的私钥解密出会话密钥。
5. Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。

服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书

客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）





1. 客户端向服务器发送请求，同时发送客户端支持的<u>一套加密规则</u>（包括对称加密、非对称加密、摘要算法）；
2. 服务器从中选出一组加密算法与HASH算法，并将自己的**身份信息以证书的形式发回给浏览器**。证书里面包含了网站地址，**加密公钥**（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；
3. **客户端验证服务器的合法性**，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；
4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个**随机密钥**（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行**摘要**计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用**对称加密的密钥加密握手消息**发给浏览器；
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

总结：**非对称加密算法用于在握手过程中加密生成的密码**；**对称加密算法用于对真正传输的数据进行加密**；**HASH算法用于验证数据的完整性**。

#### 对称加密和非对称加密

- 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
- 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA
- 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

#### 数字签名、报文摘要的原理

- 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。
- 摘要算法:MD5、SHA

### GET与POST的区别？

1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
2. **GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；**
3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。**POST的参数不会被保存，安全性相对较高；**
5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

### Session与Cookie的区别？

Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

- Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；

- Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。

### 从输入网址到获得页面的过程 (越详细越好)

1. 浏览器查询  DNS，**获取域名对应的IP地址**:具体过程包括浏览器搜索自身的<u>DNS缓存</u>、搜索<u>操作系统的DNS缓存</u>、<u>读取本地的Host文件</u>和<u>向本地DNS服务器进行查询</u>等。

   对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

2. 浏览器**获得域名对应的IP地址以后**，浏览器**向服务器请求建立链接**，发起**三次握手**；

3. TCP/IP链接建立起来后，浏览器向服务器**发送HTTP请求**；

4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并**将处理结果及相应的视图返回给浏览器**；

5. 浏览器**解析并渲染视图**，若遇到对js文件、css文件及图片等静态<u>资源的引用</u>，则**重复上述步骤并向服务器请求这些资源**；

6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

   #### DNS解析有两种方式：**递归查询**和**迭代查询**

   * 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。
   * 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果

### HTTP请求有哪些常见状态码？

1. 1xx：表示通知信息，如请求收到了或正在进行处理。100      Continue：继续，客户端应继续其请求     
2. 2xx状态码：操作成功。200 OK
3. 3xx状态码：重定向。301 永久重定向；302暂时重定向
4. 4xx状态码：**客户端错误**。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
5. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用

## 其他

###  单条记录高并发访问的优化

服务器端：

* 使用缓存，如redis等
* 使用分布式架构进行处理
* 将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回
* 将静态资源尽可能在客户端进行缓存
* 采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）

数据库端：

* 数据库采用主从赋值，读写分离措施
* 建立适当的索引
* 分库分表

### 介绍一下ping的过程，分别用到了哪些协议

详见：[Ping原理与ICMP协议](https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html)

**ping是使用ICMP协议来进行工作的。** ICMP:网络控制报文协议

* 首先，ping命令会构建一个<u>ICMP请求数据包</u>，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。
* 然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。
* 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。

目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。